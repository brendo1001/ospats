box
sample(1:12,1,prob=content)
?sample
content
box=vector(mode="list",length=12)
#random allocation
alloc=sample(1:12,length(paca),rep=TRUE)
content=rep(0,12)
for (i in 1:12){
box[[i]]=paca[alloc==i]
content[i]=sum(box[[i]])}
content=content*(content>0)
content
max(content)
max(content)-content
sample(1:12,1,prob=max(content)-content)
box=vector(mode="list",length=12)
#random allocation
alloc=sample(1:12,length(paca),rep=TRUE)
content=rep(0,12)
for (i in 1:12){
box[[i]]=paca[alloc==i]
content[i]=sum(box[[i]])}
content=content*(content>0)
#wrong allocation
while (max(content)>29){
i=sample(1:12,1,prob=content)
j=sample(1:length(box[[i]]),1,prob=box[[i]])
#reallocation
k=sample(1:12,1,prob=max(content)-content)
while (k==i){
k=sample(1:12,1,prob=max(content)-content)}
content[i]=content[i]-box[[i]][j]
content[i]=content[i]*(content[i]>0)
content[k]=content[k]+box[[i]][j]
box[[k]]=c(box[[k]],box[[i]][j])
box[[i]]=box[[i]][-j]}
content
box=vector(mode="list",length=12)
#random allocation
alloc=sample(1:12,length(paca),rep=TRUE)
content=rep(0,12)
for (i in 1:12){
box[[i]]=paca[alloc==i]
content[i]=sum(box[[i]])}
content=content*(content>0)
#wrong allocation
while (max(content)>25){
i=sample(1:12,1,prob=content)
j=sample(1:length(box[[i]]),1,prob=box[[i]])
#reallocation
k=sample(1:12,1,prob=max(content)-content)
while (k==i){
k=sample(1:12,1,prob=max(content)-content)}
content[i]=content[i]-box[[i]][j]
content[i]=content[i]*(content[i]>0)
content[k]=content[k]+box[[i]][j]
box[[k]]=c(box[[k]],box[[i]][j])
box[[i]]=box[[i]][-j]}
ox=vector(mode="list",length=12)
#random allocation
alloc=sample(1:12,length(paca),rep=TRUE)
content=rep(0,12)
for (i in 1:12){
box[[i]]=paca[alloc==i]
content[i]=sum(box[[i]])}
content=content*(content>0)
#wrong allocation
while (max(content)>26){
i=sample(1:12,1,prob=content)
j=sample(1:length(box[[i]]),1,prob=box[[i]])
#reallocation
k=sample(1:12,1,prob=max(content)-content)
while (k==i){
k=sample(1:12,1,prob=max(content)-content)}
content[i]=content[i]-box[[i]][j]
content[i]=content[i]*(content[i]>0)
content[k]=content[k]+box[[i]][j]
box[[k]]=c(box[[k]],box[[i]][j])
box[[i]]=box[[i]][-j]}
box=vector(mode="list",length=12)
#random allocation
alloc=sample(1:12,length(paca),rep=TRUE)
content=rep(0,12)
for (i in 1:12){
box[[i]]=paca[alloc==i]
content[i]=sum(box[[i]])}
content=content*(content>0)
#wrong allocation
while (max(content)>27){
i=sample(1:12,1,prob=content)
j=sample(1:length(box[[i]]),1,prob=box[[i]])
#reallocation
k=sample(1:12,1,prob=max(content)-content)
while (k==i){
k=sample(1:12,1,prob=max(content)-content)}
content[i]=content[i]-box[[i]][j]
content[i]=content[i]*(content[i]>0)
content[k]=content[k]+box[[i]][j]
box[[k]]=c(box[[k]],box[[i]][j])
box[[i]]=box[[i]][-j]}
content
i=sample(1:12,1,prob=content)
j=sample(1:length(box[[i]]),1,prob=box[[i]])
#reallocation
k=sample(1:12,1,prob=max(content)-content)
i
k
load("C:/Users/bmalone/Dropbox/2016/philHughes/plotfunctions.RData")
rowcompare()
?rowcompare()
rowcompare
asd
View(asd)
Rowplot2(“ORBWAR”, “HYEDEQ”, “property”)
View(asd)
Rowplot2(“OR BW AR”, “HY ED EQ”, “property”)
names(asd)
Rowplot2(“OR BW AR”, “HY ED EQ”, “Bsat.70...80”)
Rowplot2(“OR BW AR”, “HY ED EQ”, “Bsat.70...80”, d1=asd)
rowplot2(“OR BW AR”, “HY ED EQ”, “Bsat.70...80”, d1=asd)
rowplot2(“OR BW AR”, “HY ED EQ”, “Bsat.70...80”)
rowplot2(OR BW AR, HY ED EQ, “Bsat.70...80”)
rowplot2("OR BW AR", "HY ED EQ", "Bsat.70...80”)
rowplot2("OR BW AR", "HY ED EQ", "Bsat.70...80” )
)
)
rowplot2("OR BW AR", "HY ED EQ", "Bsat.70...80” )
rowplot2( "OR BW AR", "HY ED EQ" )
rowplot2( "OR BW AR", "HY ED EQ" , prp="carbon", d1 = asd)
names(asd)
rowplot2( "OR BW AR", "HY ED EQ" , prp="Clay.15...20", d1 = asd)
rowplot2( "OR BW AR", "HY CS FY" , prp="Clay.15...20", d1 = asd)
rowplot2( "OR BW AR", "HY CS FY" , prp="clay", d1 = asd)
library(ithir); library(raster);library(sp); library(rgdal); library(MASS);library(gstat);library(randomForest);library(snow); library(doParallel)
list.files("C:/Users/bmalone/Dropbox/quentin2015_dsm/rasters",  pattern="tif$", full.names=FALSE)
files<- list.files("C:/Users/bmalone/Dropbox/quentin2015_dsm/rasters", pattern='tif$',full.names=T)
files
elevation<-raster(files[1])
plot(elevation)
r2<- raster(files[1])
for(i in 2:length(files)){
r2<- stack(r2,files[i])}
r2
list.files("C:/Users/bmalone/Dropbox/2016\DAFF/quentin/data/nationalGrids/cropped/processed/simulations/perc50",  pattern="tif$", full.names=FALSE)
list.files("C:/Users/bmalone/Dropbox/2016/DAFF/quentin/data/nationalGrids/cropped/processed/simulations/perc50",  pattern="tif$", full.names=FALSE)
c.maps<- list.files("C:/Users/bmalone/Dropbox/2016/DAFF/quentin/data/nationalGrids/cropped/processed/simulations/perc50", pattern='tif$',full.names=T)
c.maps
plot(raster(c.maps[1]))
lo=1
cpus = 2 # The number of nodes/cores to use in the cluster
cl <- makeCluster(spec = cpus)
registerDoParallel(cl)
c.grid<- raster(c.maps[lo])
crs(c.grid)<- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
newProj<- "+proj=lcc +lat_1=-18 +lat_2=-36 +lat_0=0 +lon_0=134 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
c.grid<- projectRaster(c.grid, crs=newProj,method="bilinear", res=100)
thresh<-  0.0075
diogRMSE_EVall<- matrix(NA,ncol=3,nrow=100)
nm1<- paste(paste("I:/work2016/DAFF/quentin/data/dissever/","sim_", sep=""), lo, sep="") #### Important for consideration
nm1<- paste(paste("C:/Users/bmalone/Dropbox/2016/DAFF/quentin/data/dissever/","sim_", sep=""), lo, sep="") #### Important for consideration
nm1
dir.create(nm1,showWarnings = F)
c.gridCELL<- writeRaster(rasterFromXYZ(cbind(xyFromCell(c.grid, cell=seq(1,ncell(c.grid)), spatial=FALSE),seq(1:ncell(c.grid)))),filename=paste(nm1, "/cellNumbers_coarse.tif", sep=""),format="GTiff",progress=F,overwrite=T)
c.grid_ds<- resample(c.grid, r2[[1]],method="ngb", filename=paste(nm1, "/Initialisation_fineRes.tif", sep=""),format="GTiff",progress=F,overwrite=T) #values
c.gridCELL_ds<- resample(c.gridCELL, r2[[1]],method="ngb", filename=paste(nm1,"/cellNumbers_fineRes.tif", sep=""),format="GTiff",progress=F,overwrite=T) #cell numbers
#Make a stack of the coarse grid prediction, cell numbers and covariates
r1<- stack(c.grid_ds,c.gridCELL_ds)
#take a sample for modelling
r3<- stack(r1,r2) # values and covariates
sr<-as.data.frame(sampleRandom(r3,2500)) # sample random grid cells
names(sr)[1]<- "value"
#Fit model (Initialisation)
fitModel<-randomForest(x= sr[,3:ncol(sr)], y= sr$value ,data=sr)
map1 <- predict(r2,fitModel, type="response",filename=paste(nm1,"/gamMap1.tif", sep=""),format="GTiff",progress=T,overwrite=T)
#plot(map1)
names(map1)<- "map1"
c.dat<- as.data.frame(c.grid)
c.datXY<- xyFromCell(c.grid, cell=seq(1,ncell(c.grid)), spatial=FALSE)
c.dat<- cbind(seq(1,ncell(c.grid)),c.datXY,c.dat)
names(c.dat)[1]<- "cell"
c.dat_ref<- c.dat[which(complete.cases(c.dat)),] #complete cases
#message("Dissever iteration")
for (zz in 1:100){
#stack predictions and cell numbers (fine grid)
r4<- stack(c.gridCELL_ds,map1)
r4.dat<-as.data.frame(r4)
r4.dat<- r4.dat[which(complete.cases(r4.dat)),] #complete cases
downFit<-aggregate(r4.dat$map1,list(group=r4.dat$cellNumbers_coarse),mean) # average within coarse grid
#merge
xx<- merge(c.dat_ref, downFit, by.x = "cell", by.y = "group")
names(xx)<- c("cell", "X", "Y", "C_grid", "F_grid")
#RMSE
diogRMSE_EVall[zz,2]<- sqrt(mean((xx$C_grid -xx$F_grid)^2))
#calculate adjustment factor
xx$AF<- -99999
xx$AF[which(complete.cases(xx))]<- xx$C_grid/xx$F_grid
xx[xx == -99999] <- NA
#make adjustment factor raster
fs<- paste(nm1,paste("/iter_",zz,sep=""),sep="")
AF.grid<- writeRaster(rasterFromXYZ(xx[,c(2,3,6)]),filename=paste(fs,"AF1_coarse.tif",sep="_"),format="GTiff",progress=F,overwrite=T)
#fine grid
AF.grid_ds<- resample(AF.grid, r2[[1]],method="ngb", filename=paste(fs,"AF1_fine.tif",sep="_"),format="GTiff",progress=F,overwrite=T)
#plot(AF.grid_ds)
#do the adjustment
r5<- stack(map1,AF.grid_ds)
f1 <- function(x) (x[[1]]*x[[2]])
upd.test <- calc(r5, fun=f1, filename=paste(fs,"update_fine.tif",sep="_"),format="GTiff",progress=F,overwrite=T)
names(upd.test)<- names(c.grid_ds)
#plot(upd.test)
###DO the modelling
#take a sample for modelling
r1<- stack(upd.test,c.gridCELL_ds)
r3<- stack(r1,r2)
sr<-as.data.frame(sampleRandom(r3,2500)) # sample random grid cells
names(sr)[1]<- "value"
#Fit model (iteration)
fitModel<-randomForest(x= sr[,3:ncol(sr)], y= sr$value ,data=sr)
#predict model
map2 <- predict(r2,fitModel,type="response",filename=paste(fs,"pred_fine.tif",sep="_"),format="GTiff",progress=T,overwrite=T)
#plot(map2)
#criteria
message("RMSE = ",round(diogRMSE_EVall[zz,2],3))
if (zz >= 5) {
FF<- mean(abs(diogRMSE_EVall[zz-2,2]-diogRMSE_EVall[zz-1,2])+ abs(diogRMSE_EVall[zz-1,2]-diogRMSE_EVall[zz,2]) + abs(diogRMSE_EVall[zz-2,2]-diogRMSE_EVall[zz,2]))
if (FF <= thresh) {
diogRMSE_EVall<- diogRMSE_EVall[which(complete.cases(diogRMSE_EVall)),]
diogRMSE_EVall<- as.data.frame(diogRMSE_EVall)
write.table(diogRMSE_EVall, file =paste(nm1, "/rmse_estimates.txt", sep=""), sep = ",", row.names = F, col.names = T)
break}}
map1<- map2
names(map1)<- "map1"}
stopCluster(cl)
lo=1
c.grid<- raster(c.maps[lo])
crs(c.grid)<- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"
newProj<- "+proj=lcc +lat_1=-18 +lat_2=-36 +lat_0=0 +lon_0=134 +x_0=0 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
c.grid<- projectRaster(c.grid, crs=newProj,method="bilinear", res=100)
#c.grid
##Dissever parameters
thresh<-  0.0075
#message("Dissever initialisation")
diogRMSE_EVall<- matrix(NA,ncol=1,nrow=100)
#location of where outputs go
nm1<- paste(paste("C:/Users/bmalone/Dropbox/2016/DAFF/quentin/data/dissever/","sim_", sep=""), lo, sep="") #### Important for consideration
dir.create(nm1,showWarnings = F)
#grid preparation
#get the cell numbers of the grid
c.gridCELL<- writeRaster(rasterFromXYZ(cbind(xyFromCell(c.grid, cell=seq(1,ncell(c.grid)), spatial=FALSE),seq(1:ncell(c.grid)))),filename=paste(nm1, "/cellNumbers_coarse.tif", sep=""),format="GTiff",progress=F,overwrite=T)
#resample coarse grids to fine grid
c.grid_ds<- resample(c.grid, r2[[1]],method="ngb", filename=paste(nm1, "/Initialisation_fineRes.tif", sep=""),format="GTiff",progress=F,overwrite=T) #values
c.gridCELL_ds<- resample(c.gridCELL, r2[[1]],method="ngb", filename=paste(nm1,"/cellNumbers_fineRes.tif", sep=""),format="GTiff",progress=F,overwrite=T) #cell numbers
#Make a stack of the coarse grid prediction, cell numbers and covariates
r1<- stack(c.grid_ds,c.gridCELL_ds)
#take a sample for modelling
r3<- stack(r1,r2) # values and covariates
sr<-as.data.frame(sampleRandom(r3,2500)) # sample random grid cells
names(sr)[1]<- "value"
#Fit model (Initialisation)
fitModel<-randomForest(x= sr[,3:ncol(sr)], y= sr$value ,data=sr)
#varImpPlot(fitModel)
#fitModel
#summary(fitModel)
#predict model
map1 <- predict(r2,fitModel, type="response",filename=paste(nm1,"/gamMap1.tif", sep=""),format="GTiff",progress=T,overwrite=T)
#plot(map1)
names(map1)<- "map1"
#coarse grid table
c.dat<- as.data.frame(c.grid)
c.datXY<- xyFromCell(c.grid, cell=seq(1,ncell(c.grid)), spatial=FALSE)
c.dat<- cbind(seq(1,ncell(c.grid)),c.datXY,c.dat)
names(c.dat)[1]<- "cell"
c.dat_ref<- c.dat[which(complete.cases(c.dat)),] #complete cases
#message("Dissever iteration")
for (zz in 1:100){
#stack predictions and cell numbers (fine grid)
r4<- stack(c.gridCELL_ds,map1)
r4.dat<-as.data.frame(r4)
r4.dat<- r4.dat[which(complete.cases(r4.dat)),] #complete cases
downFit<-aggregate(r4.dat$map1,list(group=r4.dat$cellNumbers_coarse),mean) # average within coarse grid
#merge
xx<- merge(c.dat_ref, downFit, by.x = "cell", by.y = "group")
names(xx)<- c("cell", "X", "Y", "C_grid", "F_grid")
#RMSE
diogRMSE_EVall[zz,1]<- sqrt(mean((xx$C_grid -xx$F_grid)^2))
#calculate adjustment factor
xx$AF<- -99999
xx$AF[which(complete.cases(xx))]<- xx$C_grid/xx$F_grid
xx[xx == -99999] <- NA
#make adjustment factor raster
fs<- paste(nm1,paste("/iter_",zz,sep=""),sep="")
AF.grid<- writeRaster(rasterFromXYZ(xx[,c(2,3,6)]),filename=paste(fs,"AF1_coarse.tif",sep="_"),format="GTiff",progress=F,overwrite=T)
#fine grid
AF.grid_ds<- resample(AF.grid, r2[[1]],method="ngb", filename=paste(fs,"AF1_fine.tif",sep="_"),format="GTiff",progress=F,overwrite=T)
#plot(AF.grid_ds)
#do the adjustment
r5<- stack(map1,AF.grid_ds)
f1 <- function(x) (x[[1]]*x[[2]])
upd.test <- calc(r5, fun=f1, filename=paste(fs,"update_fine.tif",sep="_"),format="GTiff",progress=F,overwrite=T)
names(upd.test)<- names(c.grid_ds)
#plot(upd.test)
###DO the modelling
#take a sample for modelling
r1<- stack(upd.test,c.gridCELL_ds)
r3<- stack(r1,r2)
sr<-as.data.frame(sampleRandom(r3,2500)) # sample random grid cells
names(sr)[1]<- "value"
#Fit model (iteration)
fitModel<-randomForest(x= sr[,3:ncol(sr)], y= sr$value ,data=sr)
#predict model
map2 <- predict(r2,fitModel,type="response",filename=paste(fs,"pred_fine.tif",sep="_"),format="GTiff",progress=T,overwrite=T)
#plot(map2)
#criteria
message("RMSE = ",round(diogRMSE_EVall[zz,1],3))
if (zz >= 5) {
FF<- mean(abs(diogRMSE_EVall[zz-2,1]-diogRMSE_EVall[zz-1,1])+ abs(diogRMSE_EVall[zz-1,1]-diogRMSE_EVall[zz,1]) + abs(diogRMSE_EVall[zz-2,1]-diogRMSE_EVall[zz,1]))
if (FF <= thresh) {
diogRMSE_EVall<- diogRMSE_EVall[which(complete.cases(diogRMSE_EVall)),]
diogRMSE_EVall<- as.data.frame(diogRMSE_EVall)
write.table(diogRMSE_EVall, file =paste(nm1, "/rmse_estimates.txt", sep=""), sep = ",", row.names = F, col.names = T)
break}}
map1<- map2
names(map1)<- "map1"}
sqrt(1681)
cubs=(34:999)^2 #perfect square
cubs
cubs=(33:999)^2 #perfect square
20^2
25^2
30^2
31^2
32^2
cubs=(32:999)^2 #perfect square
cubs=cubs[cubs%%10>0] #no 0 at the end
cubs
trubs=trunc(cubs/100)
trubs
difs=apply(abs(outer(cubs,trubs,"-")),2,min)
difs
?outer
cubs=(32:999)^2 #perfect square
cubs=cubs[cubs%%10>0] #no 0 at the end
cubs=(32:999)^2 #perfect square
cubs=cubs[cubs%%10>0] #no 0 at the end
trubs=trunc(cubs/100)
difs=apply(abs(outer(cubs,trubs,"-")),2,min)
mots=cubs[difs==0]
cubs=(1:999)^2 #perfect square
cubs=cubs[cubs%%10>0] #no 0 at the end
trubs=trunc(cubs/100)
difs=apply(abs(outer(cubs,trubs,"-")),2,min)
mots=cubs[difs==0]
mots
1681\`00
install.packages("ithir", repos = "http://R-Forge.R-project.org")
library(ithir)
getwd()
data(meuse.grid)
library(raster)
data(meuse.grid)
b <- rasterFromXYZ(meuse.grid)
projection(b) <- "+init=epsg:28992"
# transform to longitude/latitude
p <- projectRaster(b, crs="+proj=longlat +datum=WGS84", method='ngb')
KML(p, file='meuse.kml')
plot(p)
b <- raster("C:/Users/bmalone/Downloads/peat.tif")
b
plot(p)
plot(b)
p <- projectRaster(b, crs="+proj=longlat +datum=WGS84", method='ngb')
plot(p)
KML(p, file='peat.kml')
dat<- getValues(p)
head(dat)
tempD <- data.frame(cellNos = seq(1:ncell(p)))
vals <- as.data.frame(getValues(p))
tempD <- cbind(tempD, vals)
tempD <- tempD[complete.cases(tempD), ]
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(covStack, cellNos, spatial = FALSE))
gXY <- data.frame(xyFromCell(p, cellNos, spatial = FALSE))
tempD <- cbind(gXY, tempD)
str(tempD)
p1<- rasterFromXYZ(tempD[,c(1,2,4)])
p1
p
KML(p1, file='peat1.kml')
b
data(meuse.grid)
b <- rasterFromXYZ(meuse.grid)
projection(b) <- "+init=epsg:28992"
# transform to longitude/latitude
p <- projectRaster(b, crs="+proj=longlat +datum=WGS84", method='ngb')
plot(p)
p
p[[1]]
getValues(p[[1]])
install.packages("plotKML")
library(plotKML)
data(eberg_grid)
View(eberg_grid)
gridded(eberg_grid) <- ~x+y
proj4string(eberg_grid) <- CRS("+init=epsg:31467")
data(SAGA_pal)
plotKML(eberg_grid["TWISRT6"], colour_scale = SAGA_pal[[1]])
View(tempD)
names(tempD)
names(tempD)<- c("x", "y", "cell", "peat")
gridded(tempD) <- ~x+y
proj4string(tempD) <- CRS("+proj=longlat +datum=WGS84")
plotKML(tempD["peat"], colour_scale = SAGA_pal[[1]])
library(raster); library(plotKML); library(rgdal)
plotKML(tempD["peat"], colour_scale = SAGA_pal[[1]])
plotKML(tempD["peat"], colour_scale = SAGA_pal[[1]],kmz=T)
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:/Program Files/7-Zip/7zFM.exe")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:/Program Files/7-Zip/")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:/Program Files/7-Zip/7zFM.exe")
Sys.getenv("R_ZIPCMD", "zip")
Sys.getenv("R_ZIPCMD", "zip")
Sys.getenv("R_ZIPCMD", "zip")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:/Program Files/7-Zip")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:\Program Files\7-Zip")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:/Program Files/7-Zip")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:/Program Files/7-Zip/7z.exe")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:/Program Files/7-Zip/7z.exe")
getwd()
setwd("C:/temp")
kml_compress("C:/Users/bmalone/Documents/tempD__peat__.kml",zip = "C:/Program Files/7-Zip/7z.exe")
setwd("C:/Users/bmalone/Documents")
kml_compress("tempD__peat__.kml",zip = "C:/Program Files/7-Zip/7z.exe")
setwd("Z:/rdev/ospats/muddles/")
dat<- read.table("NowleyCStock2014_75m.txt", header = T, sep = ",", row.names = F)
dat<- read.table("NowleyCStock2014_75m.txt", header = T, sep = ",")
View(dat)
dat<- dat[,c(1,2,4,5)]
View(dat)
names(dat)<- c("X", "Y", "Pred", "S2")
View(dat)
nowley_Cstock <- dat
nowley_Cstock <- dat
save(nowley_Cstock, file= "Z:/rdev/ospats/data/nowley_Cstock.rda")
library(raster);library(gstat);library(Rcpp);library(RcppArmadillo)
data<- nowley_Cstock
p.map<- rasterFromXYZ(data[,c(1:3)])
plot(p.map)
u.map<- rasterFromXYZ(data[,c(1,2,4)])
plot(u.map)
vgm1 <- variogram(s2~1, ~x+y, data, width= 100)
vgm1 <- variogram(s2~1, ~X+Y, data, width= 100)
View(data)
vgm1 <- variogram(S2~1, ~X+Y, data, width= 100)
mod1<-vgm(psill= var(data$s2), "Exp", range= 1000, nugget = 0)
mod1<-vgm(psill= var(data$S2), "Exp", range= 1000, nugget = 0)
model_globe<-fit.variogram(vgm1, mod1)
model_globe
plot(vgm1,model=model_globe)
ra<- 575 #spatial 'range' for error (from variogram)
ncy<- 400
start<- 1
maxrun<- 1
R2<-  0.4 #R2 of regression
H<- 5 # no strata
source('Z:/rdev/ospats/R/ospatsF.R')
#Run Function
tester<- ospatsF(data= data,
dRange= ra,
nCycles= ncy,
dStart= 0,
ClusterStart = c() , # external for dStart == 3
dMaxrun=1,
dRSquare=0.4,
dStrata=4,
initialTemperature = 1,
coolingRate = 0.95,
debug=FALSE,
verbose=TRUE)
Rcpp::sourceCpp('Z:/rdev/ospats/src/fastPdist.cpp')
Rcpp::sourceCpp('Z:/rdev/ospats/src/fastVsum.cpp')
Rcpp::sourceCpp('Z:/rdev/ospats/src/RcppExports.cpp')
#Run Function
tester<- ospatsF(data= data,
dRange= ra,
nCycles= ncy,
dStart= 0,
ClusterStart = c() , # external for dStart == 3
dMaxrun=1,
dRSquare=0.4,
dStrata=4,
initialTemperature = 1,
coolingRate = 0.95,
debug=FALSE,
verbose=TRUE)
tester<- ospatsF(data= data,
dRange= ra,
nCycles= ncy,
dStart= 0,
ClusterStart = c() , # external for dStart == 3
dMaxrun=2,
dRSquare=0.4,
dStrata=4,
initialTemperature = 1,
coolingRate = 0.95,
debug=FALSE,
verbose=TRUE)
r1<- rasterFromXYZ(tester[[2]][,c(1,2,5)])
plot(r1, main="ospats stratification")
nclass<-  100
strat0<- cumsqfDel(z= data[,3], nclass= nclass, ns= 5)[[1]]
r2<- rasterFromXYZ(cbind(tester[[2]][,c(1,2)],strat0))
